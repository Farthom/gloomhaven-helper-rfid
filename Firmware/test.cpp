// Sockets
#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
#include <thread>
#include <chrono>

#include <vector>
#include <stdint.h>

#include "protocol.hpp"
#include "gameState.hpp"
#include "message.hpp"
#include "print.hpp"
#include "inputStream.hpp"
#include "header.hpp"
#include "utils.hpp"

const uint16_t port = 58888;
const char *host = "127.0.0.1";
int message_number;
ghr::GameState state;

// const std::vector<const int32_t> input_dummy_buffer{0x00, -1, 0x01, -1, 0x73, -1, -1};
// const std::vector<int32_t> input_dummy_buffer{
//     0x00, -1, 0x05, 0x76, -1, 0x20, 0x37, -1, 0x2e, 0x36, -1, 0x00, 0x00, 0x01, 0x73, -1,
//     0xa6,
//     0x01, 0x00, 0x00, 0x0c, 0x10, 0x01, 0x3a, 0x03, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01,
//     0x00, 0x03, 0x14, 0x00, 0x01, 0x01, 0x00, 0x03, 0x03, 0x01, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00,
//     0x03, 0x00, 0x01, 0x03, 0x02, 0x04, 0x03, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
//     0x06, 0x00, 0x00, 0x08, 0x35, 0x33, 0x37, 0x31, -1, 0x36, 0x34, 0x30, 0x32, 0x0a, 0x00, 0x00, 0x08,
//     0x51, 0x52, 0x57, 0x55, 0x56, 0x54, 0x53, 0x50, 0x0b, 0x00, 0x00, 0x08, 0x5c, 0x5f, 0x58, 0x5d,
//     0x5e, 0x5b, 0x59, 0x5a, 0x0d, 0x00, 0x00, 0x08, 0x6c, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x6b, 0x6a,
//     0x06, 0x01, 0x52, 0x6f, 0x62, 0x69, 0x6e, 0x20, 0x61, 0x64, 0x73, 0x66, 0xe1, 0x06, 0x00, 0x0c,
//     0x0c, 0x07, 0x00, 0x00, 0x00, -1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x04, 0x00, 0x04, 0x06,
//     0x01, 0x00, 0x31, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x03, 0x00, 0x00, 0x00,
//     0x00, 0x00, 0x0e, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
//     0x06, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00

// };
// const std::vector<int32_t> input_dummy_buffer{
//     // 0x00, 0x05, 0x76, 0x20, 0x37, 0x2e, 0x33, 0x00, -1
//     0x00, 0x01, 0x73, 0x04, 0, 0, 0, 1, -1};

const std::vector<int32_t> input_dummy_buffer{
    0x00, -1, 0x05, 0x76, -1, 0x20, 0x37, -1, 0x2e, 0x36, -1, 0x00, 0x00, 0x01, 0x73, -1,
    0xe6,
    0x01,
    0x00, 0x00, 0x0c, 0x2d, 0x01, 0x3a, 0x03, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x00, 0x00,
    0x03, 0x14, 0x00, 0x01, 0x01, 0x00, 0x03, 0x03, 0x01, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x01, 0x03, 0x02, 0x04, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
    0x01, 0x01, 0x08, 0x04, 0x03, 0x00, 0x06, 0x01, 0x02, 0x05, 0x07, 0x06, 0x00, 0x00, 0x08, 0x35,
    0x33, 0x37, 0x31, 0x36, 0x34, 0x30, 0x32, 0x0a, 0x00, 0x00, 0x08, 0x51, 0x52, 0x57, 0x55, 0x56,
    0x54, 0x53, 0x50, 0x0b, 0x00, 0x00, 0x08, 0x5c, 0x5f, 0x58, 0x5d, 0x5e, 0x5b, 0x59, 0x5a, 0x0d,
    0x00, 0x00, 0x08, 0x6c, 0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x6b, 0x6a, 0x03, 0x01, 0x52, 0x6f, 0x62,
    0x69, 0x6e, 0x20, 0x61, 0x64, 0x73, 0x66, 0xe1, 0x06, 0x00, 0x0b, 0x0c, 0x07, 0x00, 0x0b, 0x01,
    0x07, 0x00, 0x01, 0x07, 0x00, 0x00, 0x01, 0x01, 0x03, 0x01, 0x01, 0x02, 0x03, 0x01, 0x0e, 0x0e,
    0x01, 0x05, 0x00, 0x01, 0x05, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x04, 0x01, 0x01, 0x0d,
    0x0d, 0x01, 0x09, 0x00, 0x00, 0x05, 0x01, 0x01, 0x0d, 0x0d, 0x01, 0x04, 0x00, 0x00, 0x01, 0x00,
    0x01, 0x08, 0x08, 0x01, 0x06, 0x00, 0x00, 0x02, 0x00, 0x01, 0x08, 0x08, 0x01, 0x08, 0x00, 0x00,
    0x03, 0x00, 0x01, 0x08, 0x08, 0x02, 0x01, 0x0a, 0x00, 0x00, 0x01, 0x80, 0x04, 0x03, 0x04, 0x06,
    0x01, 0x02, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x02, 0x03, 0x04, 0x05, 0x01,
    0x02, 0x02, 0x00, 0x00, 0x00, 0x00};

// const std::vector<int32_t> input_dummy_buffer{
//     0x00, -1, 0x05, 0x76, -1, 0x20, 0x37, -1, 0x2e, 0x36, -1, 0x00, 0x00, 0x01, 0x73, -1,
//     0x8a,
//     0x01,
//     0x00, 0x00, 0x0c, 0x12, 0x01, 0x3a, 0x03, 0x01,
//     0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x03, 0x14, 0x00, 0x01, 0x01, 0x00, 0x03, 0x03,
//     0x01, 0x06, 0x05, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x01, 0x03, 0x02, 0x04, 0x03, 0x00, 0x00,
//     0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x06, 0x00, 0x00, 0x08, 0x35, 0x33, 0x37, 0x31, 0x36,
//     0x34, 0x30, 0x32, 0x0a, 0x00, 0x00, 0x08, 0x51, 0x52, 0x57, 0x55, 0x56, 0x54, 0x53, 0x50, 0x0b,
//     0x00, 0x00, 0x08, 0x5c, 0x5f, 0x58, 0x5d, 0x5e, 0x5b, 0x59, 0x5a, 0x0d, 0x00, 0x00, 0x08, 0x6c,
//     0x68, 0x6f, 0x6d, 0x69, 0x6e, 0x6b, 0x6a, 0x02, 0x01, 0x52, 0x6f, 0x62, 0x69, 0x6e, 0x20, 0x61,
//     0x64, 0x73, 0x66, 0xe1, 0x06, 0x00, 0x0b, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//     0x00, 0x01, 0x80, 0x04, 0x00, 0x04, 0x06, 0x01, 0x00, 0x31, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00,
//     0x00, 0x00};

// const std::vector<const int32_t> input_dummy_buffer{0x00, -1, 0x01, -1, 0x73, -1, -1, 0x00, -1, 0x05, 0x76, -1, 0x20, 0x37, -1, 0x2e, 0x36};
// const std::vector<const int32_t> input_dummy_buffer{0xa0, -1, 0x01};
// const std::vector<const int32_t> input_dummy_buffer{0xa0, -1, 0x01, -1, -1, 0xa0, -1, 0x01, 0xa0, 0x01};

int main()
{
    ghr::print("Start\n");
    int sock = 0, valread;
    struct sockaddr_in serv_addr;
    const std::size_t bufferCapacity = 1024;
    uint8_t output_buffer[bufferCapacity];
    uint8_t input_buffer[bufferCapacity];
    std::size_t end = 0, current = 0;
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        printf("\n Socket creation error \n");
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);

    // Convert IPv4 and IPv6 addresses from text to binary form
    if (inet_pton(AF_INET, host, &serv_addr.sin_addr) <= 0)
    {
        printf("\nInvalid address/ Address not supported \n");
        return -1;
    }

    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    {
        printf("\nConnection Failed \n");
        return -1;
    }
    ghr::print("Connected\n");

    auto read_network_data = [&]() {
        if (end == -1)
        {
            return -1;
        }
        if (current < end)
        {
            ghr::print("Got: ", (int)input_buffer[current], ", current: ", current, "\n");
            return (int)input_buffer[current++];
        }
        return -1;
    };
    auto read_dummy_data = [&]() {
        if (current < input_dummy_buffer.size())
        {
            return input_dummy_buffer[current++];
        }
        return -1;
    };

    auto write_dummy_data = [&](uint8_t value) {
        std::cout << std::hex << (int)value;
        std::cout << " ";
        return value;
    };

    ghr::OutputStream output(write_dummy_data, output_buffer, bufferCapacity);
    ghr::InputStream input(read_dummy_data, input_buffer, bufferCapacity);
    ghr::Header header(input, output);

    auto send_game_state = [&]() {
        int new_message_number = message_number + 1;
        std::size_t dataCapacity = 1024;
        uint8_t data[dataCapacity];
        ghr::Message msg(data, dataCapacity);
        msg.writeFullInt(new_message_number);
        int dataLength = msg.getPosition();
        header.send_data("s", "", data, dataLength);
    };
    header.on_data = [&](std::string event, std::string payload, uint8_t *data, std::size_t dataLength) {
        ghr::print("Event: ", event, ", payload: ", payload, ", data length: ", dataLength, "\n");
        ghr::Message msg(data, dataLength);
        if (event[0] == 's')
        {
            state.clear();
            message_number = msg.readFullInt();
            ghr::parseGameState(msg, state);
            ghr::print("Sending data\n");
            send_game_state();
            exit(1);
        }
    };
    while (true)
    {
        // if (current >= end)
        // {
        //     end = read(sock, (char *)buffer, bufferCapacity);
        //     ghr::print("Read network: ", end, "\n");
        //     current = 0;
        // }
        header.update();
        std::this_thread::sleep_for(std::chrono::milliseconds(1));
    }
}
